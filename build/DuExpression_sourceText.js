'function addNoise( val, quantity ) {var randomValue = random(0.9,1.1);var noiseValue = noise(valueAtTime(0) * randomValue);noiseValue = noiseValue * (quantity / 100);return val * ( noiseValue + 1 );}function checkDuikEffect(fx, duikMatchName) {if (fx.numProperties  < 3) return false;if (!!$.engineName) {if ( fx(2).name != duikMatchName ) return false;}else {try { if (fx(2).name != duikMatchName) return false; }catch (e) { return false; }}return true;}function checkEffect(fx, propIndex, propName) {if (fx.numProperties  < propIndex) return false;if (!!$.engineName) {if ( fx(propIndex).name != propName ) return false;}else {try { if (fx(propIndex).name != propName) return false; }catch (e) { return false; }}return true;}function dishineritRotation( l ) {if (typeof l === "undefined") l = thisLayer;var r = l.rotation.value;while ( l.hasParent ) {l = l.parent;r -= l.rotation.value;}return r;}function fromGroupToLayer( point ) {var matrix = getGroupTransformMatrix();return matrix.applyToPoint( point );}function fromLayerToGroup( point ) {var matrix = getGroupTransformMatrix().inverse();return matrix.applyToPoint( point );}function getCompScale( l, t ) {if (typeof l === "undefined") l = thisLayer;if (typeof t === "undefined") t = time;var originalWidth = length( l.anchorPoint, [ l.width, 0 ] );var anchorInComp = l.toComp( l.anchorPoint, t );var widthInComp = l.toComp( [ l.width, 0 ], t );var newWidth = length(anchorInComp, widthInComp);return newWidth / originalWidth;}function getEffectLayer( fx, ind ) {try { var l = fx( ind ); return l; }catch ( e ) { return null; }}function getGroupTransformMatrix( prop ) {if (typeof group === "undefined") prop = thisProperty;var matrix = new Matrix();var shapeGroups = [];var parentProp = prop.propertyGroup(1);while( parentProp && !isLayer(parentProp) ){try { if ( parentProp.transform ) shapeGroups.push( parentProp.transform ); }catch (e) {}parentProp = parentProp.propertyGroup(1);}for (var i = shapeGroups.length - 1; i >= 0; i--){var group = shapeGroups[i];matrix.translate( group.position.value );matrix.rotate( group.rotation.value );var aPX = -( group.anchorPoint.value[ 0 ] * group.scale.value[ 0 ] / 100 );var aPY = -( group.anchorPoint.value[ 1 ] * group.scale.value[ 1 ] / 100 );matrix.translate( [ aPX, aPY ] );matrix.scale( group.scale.value / 100 );}return matrix;}function getLayerCompPos( t, l ) {if (typeof l === "undefined") l = thisLayer;if (typeof t === "undefined") t = time;return l.toComp( l.anchorPoint, t );}function getLayerWorldPos(t, l) {if (typeof l === "undefined") l = thisLayer;if (typeof t === "undefined") t = time;return l.toWorld(l.anchorPoint, t);}function getLayerWorldSpeed(t, l) {return length(getWorldVelocity(t, l));}function getLayerWorldVelocity(t, l) {if (typeof t === "undefined") t = time;return (getWorldPos(t, l) - getWorldPos(t - 0.01, l)) * 100;}function getNextKey(t) {if (typeof t === "undefined") t = time;if (numKeys == 0) return null;var nKey = nearestKey(t);if (nKey.time >= t) return nKey;if (nKey.index < numKeys) return key(nKey.index + 1);return null;}function getOrientation( l ) {var r = 0;r += l.rotation.value;while ( l.hasParent ) {l = l.parent;r += l.rotation.value;}return r;}function getOrientationAtTime( l, t ) {if (typeof t === "undefined" ) t = time;var r = 0;r += l.rotation.valueAtTime( t );while ( l.hasParent ) {l = l.parent;r += l.rotation.valueAtTime( t );}return r;}function getPrevKey(t) {if (typeof t === "undefined") t = time;if (numKeys == 0) return null;var nKey = nearestKey(t);if (nKey.time <= t) return nKey;if (nKey.index > 1) return key(nKey.index - 1);return null;}function getPropWorldSpeed(t, prop) {return length(getPropWorldVelocity(t, prop));}function getPropWorldValue(t, prop) {if (typeof prop === "undefined") prop = thisProperty;if (typeof t === "undefined") t = time;if (isPosition(prop)) return getLayerWorldPos(t);return thisLayer.toWorld(prop.valueAtTime(t), t);}function getPropWorldVelocity(t, prop) {if (typeof t === "undefined") t = time;return (getPropWorldValue(t + 0.005, prop) - getPropWorldValue(t - 0.005, prop)) * 100;}function interpolationBezier(t, tMin, tMax, value1, value2, bezierPoints) {if (arguments.length !== 5) return value;var a = value2 - value1;var b = tMax - tMin;if (b == 0) return t;var c = clamp((t - tMin) / b, 0, 1);if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4) bezierPoints = [0.33,0.0,0.66,1];return a * h(c, bezierPoints) + value1;function h(f, g) {var x = 3 * g[0];var j = 3 * (g[2] - g[0]) - x;var k = 1 - x - j;var l = 3 * g[1];var m = 3 * (g[3] - g[1]) - l;var n = 1 - l - m;var d = f;for (var i = 0; i < 5; i++) {var z = d * (x + d * (j + d * k)) - f;if (Math.abs(z) < 1e-3) break;d -= z / (x + d * (2 * j + 3 * k * d));}return d * (l + d * (m + d * n));}}function isAfterLastKey() {if (numKeys == 0) return false;var nKey = nearestKey(time);return nKey.time <= time && nKey.index == numKeys;}function isLayer( prop ) {try { if ( prop.index ) return true; }catch (e) { return false; }}function isPosition(prop) {if (typeof prop === "undefined") prop = thisProperty;if (!(prop.value instanceof Array)) return false;if (prop.value.length > 3) return false;if ( prop === transform.position ) return true;if ( prop === position ) return true;return false;}function isSpatial(prop) {if (typeof prop === "undefined") prop = thisProperty;if (!(prop.value instanceof Array)) return false;if (prop.value.length != 2 && prop.value.length != 3) return false;try {sp = prop.speed;return true;} catch (e) {return false;}}function isStill(t, threshold) {if (typeof t === "undefined") t = time;if (typeof threshold === "undefined") threshold = 0.1;var d = valueAtTime(t) - valueAtTime(t + framesToTime(1));if (d instanceof Array) {for (var i = 0; i < d.length; i++) {d[i] = Math.abs(d[i]);if (d[i] >= threshold) {return false;}}return true;} else {d = Math.abs(d);return d < threshold;}}function Matrix() {/*!2D Transformation Matrix v2.7.5 LT(c) Epistemex.com 2014-2018License: MIT*/var me = this, _el;me._t = me.transform;me.a = me.d = 1;me.b = me.c = me.e = me.f = 0;}Matrix.prototype = {rotate: function(angle) {angle = degreesToRadians(angle);varcos = Math.cos(angle),sin = Math.sin(angle);return this._t(cos, sin, -sin, cos, 0, 0)},rotateFromVector: function(x, y) {return this.rotate(typeof x === "number" ? Math.atan2(y, x) : Math.atan2(x.y, x.x))},scale: function(s) {return this._t(s[0], 0, 0, s[1], 0, 0);},shear: function(sx, sy) {return this._t(1, sy, sx, 1, 0, 0)},skew: function(ax, ay) {return this.shear(Math.tan(ax), Math.tan(ay))},setTransform: function(a, b, c, d, e, f) {var me = this;me.a = a;me.b = b;me.c = c;me.d = d;me.e = e;me.f = f;return me._x()},translate: function(t) {return this._t(1, 0, 0, 1, t[0], t[1]);},transform: function(a2, b2, c2, d2, e2, f2) {varme = this,a1 = me.a,b1 = me.b,c1 = me.c,d1 = me.d,e1 = me.e,f1 = me.f;/* matrix column order is:*	a c e*	b d f*	0 0 1*/me.a = a1 * a2 + c1 * b2;me.b = b1 * a2 + d1 * b2;me.c = a1 * c2 + c1 * d2;me.d = b1 * c2 + d1 * d2;me.e = a1 * e2 + c1 * f2 + e1;me.f = b1 * e2 + d1 * f2 + f1;return me._x()},multiply: function(m) {return this._t(m.a, m.b, m.c, m.d, m.e, m.f)},inverse: function(cloneContext) {varme = this,m  = new Matrix(cloneContext ? me.context : null),dt = me.determinant();if (dt === 0) throw "Matrix not invertible.";m.a = me.d / dt;m.b = -me.b / dt;m.c = -me.c / dt;m.d = me.a / dt;m.e = (me.c * me.f - me.d * me.e) / dt;m.f = -(me.a * me.f - me.b * me.e) / dt;return m},decompose: function() {varme		= this,a		 = me.a,b		 = me.b,c		 = me.c,d		 = me.d,acos	  = Math.acos,atan	  = Math.atan,sqrt	  = Math.sqrt,pi		= Math.PI,translate = {x: me.e, y: me.f},rotation  = 0,scale	 = {x: 1, y: 1},skew	  = {x: 0, y: 0},determ	= a * d - b * c,r, s;if (a || b) {r = sqrt(a * a + b * b);rotation = b > 0 ? acos(a / r) : -acos(a / r);scale = {x: r, y: determ / r};skew.x = atan((a * c + b * d) / (r * r));}else if (c || d) {s = sqrt(c * c + d * d);rotation = pi * 0.5 - (d > 0 ? acos(-c / s) : -acos(c / s));scale = {x: determ / s, y: s};skew.y = atan((a * c + b * d) / (s * s));}else {scale = {x: 0, y: 0};}return {translate: translate,rotation : rotation,scale	: scale,skew	 : skew}},determinant: function() {return this.a * this.d - this.b * this.c},applyToPoint: function(pt) {var me = this;var x = pt[0] * me.a + pt[1] * me.c + me.e;var y = pt[0] * me.b + pt[1] * me.d + me.f;var result = [x,y];if (pt.length == 3) result.push(pt[2]);return result;},isIdentity: function() {var me = this;return me.a === 1 && !me.b && !me.c && me.d === 1 && !me.e && !me.f},isInvertible: function() {return !this._q(this.determinant(), 0)},isValid: function() {return !(this.a * this.d)},isEqual: function(m) {varme = this,q = me._q;return  q(me.a, m.a) &&q(me.b, m.b) &&q(me.c, m.c) &&q(me.d, m.d) &&q(me.e, m.e) &&q(me.f, m.f)},clone: function(noContext) {return new Matrix(noContext ? null : this.context).multiply(this)},_q: function(f1, f2) {return Math.abs(f1 - f2) < 1e-14},_x: function() {var me = this;try { if (me.context)me.context.setTransform(me.a, me.b, me.c, me.d, me.e, me.f);} catch(e) {}return me}};function translatePointWithLayer( l, point, startT, endT ) {if (typeof startT === "undefined") startT = 0;if (typeof endT === "undefined") endT = time;try {var pos = l.fromWorld( point, startT );} catch ( e ) {var pos = [ 0, 0 ];}var prevPos = l.toWorld( pos, startT );var newPos = l.toWorld( pos, endT );return newPos - prevPos;}'